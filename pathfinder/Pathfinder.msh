&BACKTRACK_TREE Pathfinder=ifelse(isdbref(first(%1)),u(backtrack_tree,%0,cat(u(get_parent,%0,first(%1),%2),%1),dec(%2)),%1)
@@ BACKTRACK_TREE: Recursively travel up the spanning tree until the location is the starting location.

@DESCRIBE Pathfinder=This code is made to find the shortest path from a list of jump points on a grid to a single destination. This object is to be used as a part of other code, and has no commands of its own. Uses a breadth-first search to find the shortest path from a list of 'Point A's to a 'Point B'. Works in any group of standard rooms with standard exits (no master/zone/dynamic exits). Made by Sketch@M*U*S*H. Bug reports, patches, and suggestions welcome.%r%r'Do' is the function to call. The second argument is the DBRef to pathfind to. The first argument is a list of tuples that take the form "DBREF:TEXT", which are the starting points. If a path is found, the output will start with the 'TEXT' portion of the tuple that began the path, followed by list of room DBRefs that lead to the destination. The text is arbitrary, but must contain no spaces or punctuation. The EXAMPLE attribute is printed here, as an example of how to call DO:%r>>%r[v(EXAMPLE)]%r<<%r%rSome helper functions have been defined for convenience: GET_EXIT_FROM0TO1 returns the exit leading from \%0 to \%1.%r%r%rCall tree: Do -> pathfind_init -> (*)pathfind -> generate tree -> (Loop: Found_target?  no-> generate_tree(expand))  ... ... (*)pathfind -> Reduce_tree -> backtrack(get_final_location) -> (loop: backtrack_tree(get_parent))

@set Pathfinder/DESCRIBE=no_command visual prefixmatch public nearby

&DO Pathfinder=u(pathfind_init,%0,%1) [@@(Call this with %0=LIST, %1=TARGET)]
@@ DO: The second argument is the DBRef to pathfind to. The first argument is a list of tuples that take the form "DBREF:TEXT".

&EXAMPLE Pathfinder=u(DO,#0:OMPHALOS #1628:LAKESIDE,#4145) [@@(On M*U*S*H, start at Omphalos Park and the Lakeside Pasture, and find the shortest path to The Golden Ducat. Returns: OMPHALOS #0 #2232 #2633 #4145)]

&EXPAND Pathfinder=cat(%0,u(remove_invalid,u(expand_list,%0,%1,inc(%2)),u(extract_locations,%0)))
@@ EXPAND: Expands the spanning tree by concatenating the current locations with those adjacent. &EXPAND_LIST generates a list of locations adjacent to the outermost locations. &REMOVE_INVALID removes all but one path to a given location, and all locations already in the tree.

&EXPAND_LIST Pathfinder=iter(u(extract_locations,graball(%0,*:*:[dec(%2)])),u(list_adjacent_rooms,%i0,:%i0:%2))
@@ EXPAND_LIST: This generates and returns a list of rooms adjacent to the outermost group of locations in the list, even rooms already IN the list!

&EXTRACT_LOCATIONS Pathfinder=regeditall(%0,v(tuple),$1)

&FOUND_TARGET Pathfinder=t(match(%0,%1:*:*))
@@ FOUND_TARGET: Returns true if the list (%0) contains the target DBRef (%1).

&GENERATE_TREE Pathfinder=ifelse(u(found_target,%0,%1),%2 %0,u(generate_tree,u(expand,%0,%1,%2),%1,inc(%2)))
@@ GENERATE_TREE: Recursively generate a spanning tree of the grid, until the target location is in the tree or the recursion limit is exceeded.

&GET_EXIT_FROM0TO1 Pathfinder=filter(#lambda/strmatch(loc(\%0),%1),lexits(%0))
@@ GET_EXIT_FROM0TO1: This takes two locations as arguments and returns the exit that links %0 to %1. This is a function to help ease coding an output formatter.

&GET_FINAL_LOCATION Pathfinder=first(u(get_final_tuple,%0,%1,%2),:)
@@ GET_FINAL_TUPLE:

&GET_FINAL_TUPLE Pathfinder=regrab(%0,\(?:[edit(%1,%b,|)]\):\[^:\]+:%2\\b)


&GET_PARENT Pathfinder=elements(grab(%0,%1:*:%2),2,:)

&LIST_ADJACENT_ROOMS Pathfinder=map(#lambda/loc(\%0)[if(%1,%1)],iter(%0,lexits(%i0)))

&PATHFIND Pathfinder=switch(u(generate_tree,%0,%1,0),#-1*,#$,u(reduce_tree,rest(#$),%1,first(#$)))

&PATHFIND_INIT Pathfinder=u(pathfind,iter(%0,%i0:0),%1,0)
@@ PATHFIND_INIT: This alters the input from &DO by adding the 'depth' counter to each tuple of the list. Since they're all starting points, their depths are 0.

&REMOVE_INVALID Pathfinder=munge(#lambda/setdiff(\%0,%1),u(extract_locations,%0),%0)
@@ REMOVE_INVALID: This is particularly dense code, and probably isn't portable due to how it uses munge(). See: &EXPAND

&REDUCE_TREE Pathfinder=u(backtrack_tree,%0,u(get_final_location,%0,%1,%2),%2)

&TUPLE Pathfinder=(#[-\d]+):([^:]+):\d+
@@ TUPLE: A regexp to match a DBRef, arbitrary text/dbref, and a number that represents search depth. Named: LOCATION:PARENT:DEPTH

&VERSION Pathfinder=1.4.1
@@ VERSION: Quite arbitrary indeed.
