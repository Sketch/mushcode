@@ Title: Garage Jobs
@@ Author: Sketch @ M*U*S*H
@@
@@ Description: An easy-to-hack +jobs system
@@
@@ Hacking:
@@
@@ Jobs and Groups are coded as their own layer, to allow changing to SQL.
@@ Whenever making database calls, always u(db,retrieve_job,%#,Job name)
@@ &db_ functions are called by &db, and define the database API.
@@ &db__ functions are private, only called by functions in &db_
@@ &db_* are functions that query the database
@@ &db_set_* are @includes that modify the database

@@ Captions cannot contain newlines
@@ Captions cannot contain newlines
@@ Groups data cannot contain newlines

@@ Todo: User interface data modeling
@@ Todo: Enforce valid job names and group names with nice error message
@@ Todo: Improve the syntax error messages on /add
@@ Todo: Warn on %# used in group attribute. (with &disable_warning_group Jobs=1)
@@ Todo?: Works on small screens

<JobRef> may be: Title or Group/Title

/list
/list <group>
/list <JobRef>
/add <group>=<caption>/<body>
/add <group>/<caption>=<body>
/take <JobRef>
/reject <JobRef>
/complete <JobRef>
/read <JobRef>
default command: +read

@create Jobs
@set Jobs=!NO_COMMAND

@@ can_nspemit removes NoSpoof info, but isn't necessary.
@power Jobs=can_nspemit

&jobs Jobs=@@ Format: &jobs`<id>_<caption|data|body> ; @@ &jobs`<id>_data =group_id|owner|ctime|...
&groups Jobs=@@ Format: &groups`<id>=Name|add_jobs_lock|see_jobs_lock|modify_jobs_lock|Description

@@ &message Jobs=@nspemit %0=udefault(message_%1,...
&message_en_prefix Jobs=JOBS:%b
&message_en_none_visible Jobs=No visible jobs matching "%0".
&message_en_job_add_denied Jobs=You may not add jobs in group "%0".
&message_en_job_see_denied Jobs=There is no group named "%0".
@@ Add ambiguous/zero determination
&message_en_job_act_denied Jobs=You may not modify jobs in group "%0".
&message_en_groupjob Jobs=Please specify jobref in the form of "group/title". (You wrote "%1")

&fun_ambiguity Jobs=switch(words(%0),>1,#-1 ambiguous,0,#-1 nonexistent,1,%0)

&cmd_add3 Jobs=$^\+jobs?/(?\:add|new) ([^=/]+)[/=]([^=/]+)[/=](.+)$:@include me/include_groupjob=%#,%1/%2; @include me/permission_create,%#,%1/%2;@include me/do_add=%#,%1/%2,%3
&cmd_take1 Jobs=$^\+jobs?/take (.+)$:@include me/include_groupjob=%#,%1;@include me/permission_see=%#,before(%1,/); @include me/permission_act,%#,%1;@include me/do_take=%#,%1

@@ TODO: strmatch(%1,nonspace/nonspace)
&include_groupjob Jobs=@assert regmatch(%1,v(regexp_groupjob))={@include me/message=%0,groupjob,%1}
&regexp_groupjob Jobs=\S+/\S+

@@ Can %0 see group %1 ?
&permission_see Jobs=@assert setr(0,u(fun_ambiguity,u(db,retrieve_group,%0,%1)))={@include me/message=%0,job_see_denied,%q0,%1}
&fun_empty_string Jobs=not(strlen(%0))

@@ Can %0 act on possibly-non-unique job %1 ?
&permission_act Jobs=@assert setr(0,u(fun_ambiguity,u(db,retrieve_job,%0,%1)))={@include me/message=%0,job_act_denied,%q0,%1}

@@ Hook method for all DB calls. Will be used here to memoize.
&db Jobs=u(me/db_%0,%1,%2,%3)

@@ %# takes non-ambiguous jobref %1.
&do_take Jobs=@include me/db_set_job_taken
&do_add Jobs=@include me/db_create_job

@@ As %0, find all visible jobs matching jobref %1
@@ Returns:
@@  1. 'None' if no group or no jobs found
@@  2. either 'List' or 'Details' followed by %r and:
@@   2a. if 'List', a list of matching job data
@@   2b. if 'Details' the details for that single job ref.


@@ | get all group data sep%r
@@ | exact_or_matching all groups 
@@ | Filter to visible groups (with u_group)
@@ | get ids of these
@@ $> jobs
@@ | make regexp u() ^([edit(%0,%r,|)])\\|
@@ | get all jobs
@@ | filter to matching jobs
@@ |> switch(words()
@@ |> return List if multi,
@@  > get details if words()==1 

&db_retrieve_job Jobs=u(db__retrieve_job_step_2,%0,%1,rest(u(db_retrieve_group,%0,%1),%r))

@@ As %0, list all jobs matching %1 of visible group-data %2
&db__retrieve_job_step_2 Jobs=switch(%2,,None, u(db__retrieve_job_step_3, u(db__mix_job_data,u(db__filter_by_job_caption,u(db__get_job_caption_attrs_from_group_datas,%2),%1)))) 

&db__get_job_caption_attrs_from_group_datas Jobs=regrep(me,jobs`*_CAPTION,u(db__jobs_regexp,%0))
&db__jobs_regexp Jobs=^\([edit(map(db__first_element_mapper,%0,%r),%r,%b)]\)\\|

&db__filter_by_job_caption Jobs=elements(%0,u(db__exact_or_matching,iter(%0,v(##),%r,%r),rest(%1,/)),%r,%r)
&db__mix_job_data Jobs=mix(db__map_job_data,%0,edit(%0,_CAPTION,_DATA),%r)
&db__mix_job_data_mixer Jobs=[v(%0)]|[v(%1)]

&db__retrieve_job_step_3 Jobs=switch(words(%0,%b),>1,List%r[iter(%0,v(##),%b,%r)],0,None,1,Details%r

@@ As %0, get all group data for group names matching %1
@@ Returns 'None', or 'List' followed by %r followed by a list of data for all matching groups
&db_retrieve_group Jobs=u(db_retrieve_group_step_2,u(db__exact_first_or_matching,u(db__get_group_data_for_ids,%0,u(db__visible_group_ids_for,%0)),%1))]

&db__retrieve_group_step_2 Jobs=switch(words(%0,%r),>1,List%r%0,1,List%r%0,None)

&db__visible_group_ids_for Jobs=filter(db__visible_group_ids_for_filter,edit(lattr(me/groups`*),%b,%r,GROUP`,),%r,%r,%0)
&db__visible_groups_ids_for_filter Jobs=elements(u(memoize,db__u_group,%1,%0),3,|)
&db__get_group_data_for_ids Jobs=iter(%1,u(memoize,db__u_group,%0,##),%r,%r)

@@ Minor stuff
&db__exact_or_matching Jobs=elements(%0,u(db__exact_or_matching_inner,map(db__first_element_mapper,%0),%1),%r,%r)
&db__first_element_mapper Jobs=first(%0,|)
&db__exact_or_matching_inner Jobs=firstof(matchall(%0,%1),matchall(%0,*%1*))

&db__u_group Jobs=u(group`%1,%0)

&db_set_job_taken Jobs=
&db_set_job_rejected Jobs=
&db_set_job_completed Jobs=
&db_create_job Jobs=


@@ Memoize calls to %0 with arguments %1-%9
&memoize Jobs=firstof(u(%0,%1,%2,%3,%4,%5,%6,%7,%8,%9)

@@ TESTING
&groups`Cool_Kids_Club Jobs=Cool Kids Club|0|0|0|Nobody is cool enough.
&groups`Building_Board Jobs=Building Board|1|1|[orflags(%0,Wr)]|Build requests go here.
&groups`Admin Jobs=Admin Board|[orflags(%0,Wr)]|[orflags(%0,Wr)]|[orflags(%0,Wr)]|Admin only.
