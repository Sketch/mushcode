@@ Title: Garage Jobs
@@ Author: Sketch @ M*U*S*H
@@
@@ Description: An easy-to-hack +jobs system
@@
@@ Hacking:
@@
@@ Jobs and Groups are coded as their own layer, to allow changing to SQL.
@@ Whenever making database calls, always u(db,retrieve_job,%#,Job name)
@@ &db_ methods are called by &db, and define the database API.
@@ &db__ methods are private, only called by functions in &db_

<JobRef> may be: Title or Group/Title

/list
/list <group>
/add <group>=<caption>/<body>
/take <JobRef>
/reject <JobRef>
/complete <JobRef>
/read <JobRef>

@create Jobs

@@ can_nspemit removes NoSpoof info, and isn't necessary.
@power Jobs=can_nspemit

&jobs Jobs=@@ Format: &jobs`<id>_<caption|data|body> ; @@ &jobs`<id>_data =group_id|owner|ctime|...
&groups Jobs=@@ Format: &groups`<id>=Name|add_jobs_lock|see_jobs_lock|modify_jobs_lock|Description

&cmd_

&message_en_prefix Jobs=JOBS:%b
&message_en_none_visible Jobs=No visible jobs matching "%0".
&message_en_job_add_denied Jobs=You may not add jobs in group "%0".
&message_en_job_see_denied Jobs=There is no group named "%0".
&message_en_job_modify_denied Jobs=You may not modify jobs in group "%0".

@@ Returns attr-list of jobs matching %1 that are visible to %0.
&fun_lookup Jobs=u(me/fun_lookup_[switch(%0,*/*,with,without)]_group,%0,%1)
&fun_lookup_with_group Jobs=
&fun_lookup_without_group Jobs=

&fun_ambiguity Jobs=switch(words(%0),>1,#-1 ambiguous,0,#-1 nonexistent,1,%0)

&cmd_take1 Jobs=$^\+jobs?/take (.+)$:@include me/permission_see=%#,before(%1,/); @include me/permission_act,%#,%1;@include me/do_take=%#,%1

@@ Can %0 see group %1 ?
&permission_see Jobs=@assert setr(0,cor(u(fun_empty_string,%1),u(fun_ambiguity,u(db,retrieve_group,%0,%1))))={@include me/message,%0,see_denied,%q0,%1}
&fun_empty_string Jobs=not(strlen(%0))

@@ Can %0 act on possibly-non-unique job %1 ?
&permission_act Jobs=@assert setr(0,u(fun_ambiguity,u(db,retrieve_job,%0,%1)))={@include me/message,%0,act_denied,%q0,%1}

@@ Hook method for all DB calls. Will be used here to memoize.
&db Jobs=u(me/db_%0,%1,%2,%3)

@@ %# takes non-ambiguous jobref %1.
&do_take Jobs=@include me/db_modify_job=

@@ As %0, find all visible jobs matching jobref %1
&db_retrieve_job Jobs=letq(0,%0,filterbool(db__job_visible_filter,filter(db__job_group_filter,grepi(me,jobs`*_caption,%1))))
&db__filter_job_group Jobs=strmatch(first(u(memoize,db__u_group,%q0,u(db__group_for_job,%0)),|),*%0*)
&db__filter_job_visible Jobs=elements(u(memoize,db__u_group,%q0,u(db__group_for_job,%0)),1,|)
&db__group_for_job Jobs=first(v(before(%1,_CAPTION)_DATA),|)
&db__u_group Jobs=u(group`%1,%0)

switch(%1,*/*,u(db_retrieve_job_without_group
@@ | match against all jobs
@@ | filter invisible jobs (by group)
@@ |>Possibly filter to requested group

@@ As %0, find all visible groups matching %1
&db_retrieve_group Jobs=letq(0,%0,filter(me/db__private_retrieve_group_filter,lattr(me/groups`*)))
&db_set_job_taken Jobs=
&db_set_job_rejected Jobs=
&db_set_job_completed Jobs=
&db_add_job Jobs=


&db__private_retrieve_group_filter Jobs=u(db__private_retrieve_group_filter_inner,u(me/%0,%q0))
&db__private_retrieve_group_filter_inner Jobs=@@TODO

@@ Memoize calls to %0 with arguments %1-%9
&memoize Jobs=u(%0,%1,%2,%3,%4,%5,%6,%7,%8,%9)
